<!DOCTYPE html>
<html>
<head>
    <title>NASDAQ S&P Growth Stoks AI generated fundamentals technicals and Latest updates</title>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.10/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script>
        // Register the datalabels plugin globally, immediately after loading it
        Chart.register(ChartDataLabels);
        // Embed Python variables as JavaScript variables
        const csvExportUrl = "https://docs.google.com/spreadsheets/d/1qwnwuUR6kOBMZqrZIX97sMetNKZyXjot-SmEWfI8LUg/export?format=csv&gid=445351489"
        // Create a global lookup for fundamentals data
        
        const GITHUB_REPO_OWNER = `prasanna-ML-expert`;
        const GITHUB_REPO_NAME = `jayind`;
        const GITHUB_RAW_URL_BASE = `https://raw.githubusercontent.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/main/`;
        const PROCESSED_DILUTION_RANGES_FILENAME = "processed_dilution_ranges.csv";
        const PROCESSED_DILUTION_RANGES_URL = GITHUB_RAW_URL_BASE + PROCESSED_DILUTION_RANGES_FILENAME;
        const tickerMap = {
            'quantum': ['ionq', 'qbts', 'rgti', 'qubt', 'laes', 'arqq'],
            'power_management_chips': ['nvts', 'on', 'aosl', 'cohr', 'mpwr', 'powi', 'alab', 'indi'],
            'lidar_sensing': ['aeva', 'invz', 'mvis', 'lidr', 'oust', 'arbe'],
            'autonomous_driving': ['mbly', 'aur', 'tsla', 'xpev', 'kdk'],
            'uas_defense_robotics': ['dpro', 'rcat', 'zena', 'onds', 'avav', 'ktos', 'umac', 'spai'],
            'service_robotics': ['rr', 'serv', 'prct', 'zbra', 'irbt'],
            'space_launch_systems': ['rklb', 'fly', 'mnts', 'spce', 'lunr', 'rdw'],
            'earth_observation': ['pl', 'bksy', 'spir', 'satl','asts', 'irdm', 'sats', 'vsat'],
            'ev_charging_infrastructure': ['evgo', 'blnk', 'chpt', 'beem', 'adse'],
            'evtol_air_mobility': ['achr', 'joby', 'evex', 'evtl'],
            'hydrogen_fuel_cells': ['fcel', 'be', 'plug', 'hyln', 'bw','bldp'],
            'batteries_storage_tech': ['qs', 'envx', 'ses', 'mvst', 'ampx', 'sldp'],
            'batteries_storage_sw': ['enph', 'stem', 'flnc', 'eose', 'gwh', 'kulr','te','nrgv'],
            'battery_materials_mining': ['atlx', 'abat', 'alb', 'sqm', 'sgml', 'elvr', 'lac', 'nb'],
            'Hyperscalers': ['crwv', 'nbis', 'corz', 'apld', 'cifr', 'wulf'],
            'Mining': [ 'mara', 'clsk', 'bitf', 'hive', 'btbt', 'hut', 'riot', 'iren'],
            'new_nuclear_energy': ['oklo', 'smr', 'nne', 'imsr','uec','ccj','leu', 'bwxt'],
            'Mag7': ['spy','aapl', 'nvda', 'meta', 'msft', 'avgo', 'goog', 'amzn'],
        };


        // Lookup object for custom dilution ranges
        let customDilutionRangesLookup = {};

        // Function to parse a single range string like "88.0/93.0"
        function parseSlashRange(rangeStr) {
            if (!rangeStr || typeof rangeStr !== 'string') return { min: NaN, max: NaN };
            const parts = rangeStr.split('/');
            if (parts.length === 2) {
                const num1 = parseFloat(parts[0]);
                const num2 = parseFloat(parts[1]);
                if (!isNaN(num1) && !isNaN(num2)) {
                    return { min: Math.min(num1, num2), max: Math.max(num1, num2) };
                }
            } else if (parts.length === 1) {
                const num = parseFloat(parts[0]);
                if (!isNaN(num)) {
                    return { min: num, max: num };
                }
            }
            return { min: NaN, max: NaN };
        }

        /***********************
              institutional details for popup
        ***********************************/

        // Dynamically fetched dilution data
        let tickerDilutionMap = {};
        async function fetchDilutionData() {
            try {
                const response = await fetch(DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawData = await response.json();
                // Assuming rawData is already in the { "TICKER": "dilution_string" } format
                // Convert all keys to uppercase for consistent lookup
                tickerDilutionMap = Object.fromEntries(
                    Object.entries(rawData).map(([key, value]) => [key.toUpperCase(), value])
                );
                console.log("Dilution data fetched successfully:", Object.keys(tickerDilutionMap).length, "tickers.");
            } catch (error) {
                console.error('Error fetching dilution data:', error);
            }
        }
        /************************
                institutional levels
        **********************************/
        // Function to parse the rawProcessedDilutionRanges string into customDilutionRangesLookup
        let industryDict = {};
        async function parseCustomDilutionRanges() {
            try {
                const response = await fetch(PROCESSED_DILUTION_RANGES_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawContent = await response.text();
                if (!rawContent) {
                    console.warn("rawProcessedDilutionRanges is empty after fetch. Skipping custom dilution range parsing.");
                    return;
                }
                const tickerRanges = rawContent.split(';');
                tickerRanges.forEach(entry => {
                    const parts = entry.split(':');
                    if (parts.length === 2) {
                        const ticker = parts[0].toUpperCase();
                        const ranges = parts[1].split(','); // Expecting "floor/ceiling"
                        if (ranges.length === 2) {
                            const floorRangeStr = ranges[0];
                            const ceilingRangeStr = ranges[1];
                            customDilutionRangesLookup[ticker] = {
                                floor: parseSlashRange(floorRangeStr),
                                ceiling: parseSlashRange(ceilingRangeStr)
                            };
                        }
                    }
                });
                console.log("Custom dilution ranges parsed successfully:", Object.keys(customDilutionRangesLookup).length, "tickers.");
            } catch (error) {
                console.error('Error fetching or parsing custom dilution ranges:', error);
            }
        }
        /***************
                options details for popup
       *******************/
        async function loadAndCleanIndustryData() {
          try {
              const response = await fetch(GITHUB_RAW_URL_BASE + 'options_detailed.json');
              const rawData = await response.json();


              // Iterate through every industry key in the JSON
              for (const [industry, content] of Object.entries(rawData)) {
                  // 1. Remove control characters (non-printable ASCII)
                  // 2. HTML Escape the resulting clean string
                  industryDict[industry] = cleanControlChars(content);
              }

              //console.log("Cleaned Industry Dictionary:", industryDict);
              return industryDict;

          } catch (error) {
              console.error("Error processing JSON file:", error);
          }
      }

      function cleanControlChars(str) {
          if (typeof str !== 'string') return str;
          // Remove control characters (Hex 00-08, 0B, 0C, 0E-1F, 7F-9F)
          const cleanStr = str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, "");
          return cleanStr;
      }
      /**
      * Strips control characters and encodes HTML entities
      */
      function htmlEscapeAndClean(str) {
          if (typeof str !== 'string') return str;

          // Remove control characters (Hex 00-1F and 7F-9F)
          // This removes hidden characters that break UI displays
          //const cleanStr = str.replace(/[\x00-\x1F\x7F\x80-\x9F]/g, "");
          const cleanStr = str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, "");

          // Standard HTML Entity Encoding
          const map = {
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&#039;'
          };

          return cleanStr.replace(/[&<>"']/g, function(m) { return map[m]; });
      }

      /*********************
              options levels
      ************************/
        const OPTIONS_DATA_FILENAME = "gemini_options.txt";
        const OPTIONS_DATA_URL = GITHUB_RAW_URL_BASE + OPTIONS_DATA_FILENAME;

        // Create a global lookup for options data
        const optionsLookup = {}; // Initialize globally, will be populated by async function

        async function fetchAndParseOptionsData() {
            try {
                const response = await fetch(OPTIONS_DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const fileContent = await response.text();

                const blocks = fileContent.trim().split(';');
                blocks.forEach(block => {
                    if (!block) return;
                    const parts = block.split(':');
                    if (parts.length === 2) {
                        const ticker = parts[0].trim().toUpperCase();
                        const rawValues = parts[1].split(',');
                        const values = rawValues.map(v => parseFloat(v));

                        if (values.length === 4 && values.every(v => !isNaN(v))) {
                            optionsLookup[ticker] = {
                                ticker: ticker,
                                callwall: values[0],
                                gammaflip: values[1],
                                putwall: values[2],
                                maxpain: values[3]
                            };
                        }
                    }
                });
                console.log("Options data fetched and parsed successfully:", Object.keys(optionsLookup).length, "tickers.");
            } catch (error) {
                console.error('Error fetching or parsing options data:', error);
            }
        }

        /************************
            govt news
        *********************************/
        const GOVT_NEWS_FILENAME = "all_govt_news_results.json";
        const GOVT_NEWS_URL = GITHUB_RAW_URL_BASE + GOVT_NEWS_FILENAME;
        let govtNewsContent = ""; // Global variable to store parsed government news

        async function fetchAndParseGovtNews() {
            try {
                const response = await fetch(GOVT_NEWS_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawData = await response.json({});
                const updates = rawData.updates || {};
                govtNewsContent = updates.news || "No government and prominent investor news available.";

                // Render the fetched content into the designated div
                const govtNewsDiv = document.getElementById('govt-news-markdown-output');
                if (govtNewsDiv) {
                    govtNewsDiv.innerHTML = marked.parse(htmlEscapeAndClean(govtNewsContent));
                }
                console.log("Government news fetched and rendered successfully.");
            } catch (error) {
                console.error('Error fetching or parsing government news:', error);
                const govtNewsDiv = document.getElementById('govt-news-markdown-output');
                if (govtNewsDiv) {
                    govtNewsDiv.innerHTML = '<p>Error loading government and prominent investor news.</p>';
                }
            }
        }
        /**************************
            Prepare industry navigation
        ********************************/
        // Function to generate the industry navigation index dynamically
        function generateIndustryIndex() {
            let navigationHtml = '<h2>Industry Index</h2><nav><ul>\n';
            let indexCounter = 1;
            for (const key in tickerMap) {
                if (tickerMap.hasOwnProperty(key)) {
                    const formattedIndustryName = key.replace(/_/g, ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
                    const tickersStr = tickerMap[key].join(', ');
                    navigationHtml += `<li><a href="#${key}">${indexCounter}. ${formattedIndustryName} (${tickersStr})</a></li>\n`;
                    indexCounter++;
                }
            }
            navigationHtml += '</ul></nav><hr/>\n';
            document.getElementById('industry-index-placeholder').innerHTML = navigationHtml;
        }

        /*************************
            fundamentals data
        **************************/
        const FUNDAMENTALS_DATA_FILENAME = "gemini_fundamentals.txt";
        const FUNDAMENTALS_DATA_URL = GITHUB_RAW_URL_BASE + FUNDAMENTALS_DATA_FILENAME;
        const fundamentalsLookup = {}; // Global lookup for fundamentals data

        async function fetchAndParseFundamentalsData() {
            try {
                const response = await fetch(FUNDAMENTALS_DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const fileContent = await response.text();

                const blocks = fileContent.trim().split(';');
                blocks.forEach(block => {
                    if (!block) return;
                    const parts = block.split(':');
                    if (parts.length === 2) {
                        const ticker = parts[0].trim().toUpperCase();
                        const rawValues = parts[1].split(',');
                        const values = rawValues.map(v => parseFloat(v));

                        // Assuming the order is debt, cash, rev, burn
                        if (values.length === 4 && values.every(v => !isNaN(v))) {
                            fundamentalsLookup[ticker] = {
                                ticker: ticker,
                                debt: values[0],
                                cash: values[1],
                                rev: values[2],
                                burn: values[3]
                            };
                        }
                    }
                });
                console.log("Fundamentals data fetched and parsed successfully:", Object.keys(fundamentalsLookup).length, "tickers.");
            } catch (error) {
                console.error('Error fetching or parsing fundamentals data:', error);
            }
        }

        /*******************
            Github technical chart updated dates
          ********************/
        async function getGithubFileLastCommitDateJs(owner, repo, path) {
            // The API endpoint remains the same
            const api_url = `https://api.github.com/repos/${owner}/${repo}/commits?path=${path}&per_page=1`;

            // We only keep the 'Accept' header; Authorization is removed
            const headers = {
                "Accept": "application/vnd.github.v3+json"
            };

            try {
                const response = await fetch(api_url, { headers: headers });

                if (!response.ok) {
                    // Awareness check: If you hit the 60-req/hour limit, you'll get a 403
                    if (response.status === 403) {
                        console.warn("GitHub API rate limit exceeded. Use a token for 5,000 reqs/hr.");
                    }
                    console.error(`Error: ${response.status} - ${response.statusText}`);
                    return "Date N/A";
                }

                const commits = await response.json();
                if (commits && commits.length > 0) {
                    const commitDateStr = commits[0].commit.author.date;
                    const dtObject = new Date(commitDateStr);

                    // Note: 'en-GB' yields '01 Jan 2026' while 'en-US' yields 'Jan 01 2026'
                    const options = { weekday: 'short', day: '2-digit', month: 'short', year: 'numeric' };
                    return dtObject.toLocaleDateString('en-GB', options).replace(/,/g, '');
                }
                return "No History";
            } catch (error) {
                console.error(`Network error for ${path}:`, error);
                return null;
            }
        }

        async function fetchAndPopulateImageUpdateDates() {
            for (const key in tickerMap) {
                if (tickerMap.hasOwnProperty(key)) {
                    const imagePath = `screenshots/${key}.png`;
                    const dateElement = document.getElementById(`chart-date-${key}`);
                    if (dateElement) {
                        dateElement.textContent = "Loading..."; // Show loading state
                        const lastModifiedDate = await getGithubFileLastCommitDateJs(
                            "prasanna-ML-expert", // GITHUB_REPO_OWNER
                            "jayind",         // GITHUB_REPO_NAME
                            imagePath
                        );
                        dateElement.textContent = `(${lastModifiedDate})`;
                    }
                }
            }
        }

        /************************
              Get news from all industries
        ***************************/

        // Function to fetch and parse all_industries_news_results.json and render news
        async function fetchAndParseAllIndustriesNews() {
            try {
                const response = await fetch(GITHUB_RAW_URL_BASE + "all_industries_news_results.json");
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data && data.updates) {
                    data.updates.forEach(item => {
                        if (item.Industry && item.Results) {
                            const industryKey = item.Industry;
                            const newsData = item.Results;
                            const newsDiv = document.getElementById(`news-content-text-${industryKey}`);
                            if (newsDiv) {
                                let contentToRender = '';
                                if ((Array.isArray(newsData) && newsData.length === 1 && newsData[0] === '0') || newsData === '0') {
                                    contentToRender = '<p>No news available for this industry.</p>';
                                } else {
                                    let full_news_text;
                                    if (Array.isArray(newsData)) {
                                        full_news_text = newsData.join(''); // newsData is an array, join it
                                    } else if (typeof newsData === 'string') {
                                        full_news_text = newsData; // newsData is already a string
                                    } else {
                                        full_news_text = String(newsData); // Convert other types to string as a fallback
                                    }

                                    // Apply cleaning and escaping in JavaScript as done before
                                    // Ensure full_news_text is a string before calling replace
                                    if (typeof full_news_text === 'string') {
                                        full_news_text = full_news_text.replace(/(\w+),\s*(\d{4})/g, '$1, $2');
                                        full_news_text = full_news_text.replace(/,\s*,/g, ',');
                                        full_news_text = full_news_text.replace(/:,/g, ':');
                                    }
                                    contentToRender = marked.parse(htmlEscapeAndClean(full_news_text));
                                }
                                newsDiv.innerHTML = contentToRender;
                            }
                        }
                    });
                }
                console.log("All industries news data fetched and parsed successfully.");
            } catch (error) {
                console.error('Error fetching or parsing all industries news data:', error);
            }
        }

        /********************
              Parse CSV data
        ************************/
        // Helper to parse CSV data into an array of objects
        const csvdataLookup = {};
        const csvdata = [];
        let headers = [];
        async function parseCsv() {
            try {
                const response = await fetch(csvExportUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                const lines = csvText.split('\n').map(line => line.endsWith('\r') ? line.slice(0, -1) : line);
                //console.log('Parsed CSV lines:', lines);
                //if (lines.length < 2 || lines.every(line => line.trim() === '')) {
                //    console.warn('CSV data is empty or contains only headers.');
                //    for (const industryKey in tickerMap) {
                //        const placeholderDiv = document.getElementById(`fundamentals-table-${industryKey}`);
                //        if (placeholderDiv) {
                //            placeholderDiv.innerHTML = '<p>No CSV data loaded or only headers found.</p>';
                //        }
                //    }
                //    return;
                //}

                headers = lines[0].split(',').map(h => h.trim());

                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim() === '') continue; // Skip empty lines

                    const currentLine = lines[i].split(',');
                    let row = {};
                    for (let j = 0; j < headers.length; j++) {
                        row[headers[j]] = (currentLine[j] || '').trim();
                    }
                    csvdata.push(row);
                    if (row['Ticker']) {
                        csvdataLookup[row['Ticker'].toUpperCase()] = row;
                    }
                }
            } catch (error) {
                console.error('Error fetching or parsing csv data:', error);
            }
        }
        // populate ticker and options buttons for all industries
        function renderDashboard() {
            for (const industryKey in tickerMap) {
                if (tickerMap.hasOwnProperty(industryKey)) {
                    let ticker_hyperlinks_html = '<div class="ticker-hyperlinks-row" style="margin-top: 10px;">\n' +
                                                 '\n   <strong>Institutional price level details:</strong>';
                    let tickerpricestr = ""; // For options levels
                    const industryTickers = tickerMap[industryKey];

                    industryTickers.forEach(ticker_symbol => {
                        const upperTicker = ticker_symbol.toUpperCase();
                        const tickerRow = csvdataLookup[upperTicker];
                        let current_price_str = 'N/A';
                        if (tickerRow && tickerRow['Price']) {
                            const price = parseFloat(tickerRow['Price']);
                            current_price_str = !isNaN(price) ? price.toFixed(2) : 'N/A';
                        }
                        tickerpricestr += `${ticker_symbol}(${current_price_str}) `;
                        ticker_hyperlinks_html += `<button class="ticker-button" onclick="toggleDilutionInline(this, '${upperTicker}', event, '${current_price_str}'); return false;" style="margin-right: 10px;">${upperTicker}</button>`;
                    });

                    ticker_hyperlinks_html += '</div>\n'; // Close ticker-hyperlinks-row

                    let options_levels_html = `<div style="margin-top: 10px; margin-bottom: 20px; padding-bottom: 10px;">` +
                                              `<strong>Options levels details:</strong> ` +
                                              `<button class="ticker-button" onclick="toggleOptionsLevelsInline(this, '${industryKey}', '${tickerpricestr}', event); return false;" style="margin-right: 10px;">${industryKey}</button>` +
                                              `</div>`;

                    const buttonContainer = document.getElementById(`buttons-container-${industryKey}`);
                    if (buttonContainer) {
                        buttonContainer.innerHTML = ticker_hyperlinks_html + options_levels_html;
                    }
                }
            }
            console.log("Dashboard buttons populated.");
        }


    function generateIndustrySections() {
        const container = document.getElementById('industry-sections-placeholder');
        if (!container) return;
        let sectionsHtml = '';
        industry_counter = 1
        for (const industry_key in tickerMap) {
          formatted_industry_name = industry_key.replace('_', ' ')
          sectionsHtml += `
          <div class="industry-section" id="${industry_key}">
              <div class="industry-header-container">
                  <h2>${industry_counter}. ${formatted_industry_name}</h2>
                  <span class="section-toggles-inline">
                      <button class="ticker-button" onclick="toggleSection('news-container-${industry_key}', this);">(News</button>
                      <button class="ticker-button" onclick="toggleSection('fundamentals-table-container-${industry_key}', this);">Price levels</button>
                      <button class="ticker-button" onclick="toggleSection('canvas-chart-container-${industry_key}', this);">Fundamentals</button>
                      <button class="ticker-button" onclick="toggleSection('charts-image-section-${industry_key}', this);">Technicals)</button>
                  </span>
                  <a href="#top" class="scroll-to-top-button">&uarr;</a>
              </div>
              <div id="news-container-${industry_key}" class="news-content hidden">\n
                <h3>Recent News</h3>\n
                <div  id="news-content-text-${industry_key}" class="markdown-output news-section">Loading news ...</div>\n
              </div>\n
              <div id="fundamentals-table-container-${industry_key}" class="fundamentals-table-content">\n
                <h3>Price levels</h3>\n
                <div id="fundamentals-table-${industry_key}">Loading Price levels...</div>\n
              </div>\n
              <div id="canvas-chart-container-${industry_key}" class="canvas-chart-content hidden">\n
                <h3>Peer Fundamentals Comparison</h3>\n
                <canvas id="chart_${industry_key}" style="max-width:100%; display:block; margin-bottom:20px;"></canvas>\n
              </div>\n
              <div id="buttons-container-${industry_key}" class="button-row" style="margin-top: 10px; margin-bottom: 2px; padding-bottom: 2px;">
              </div>
              <div id="charts-image-section-${industry_key}" class="charts-image-content hidden">
                <h3 class="charts-section">Technicals & charts <small><span id="chart-date-${industry_key}">Loading date...</span></small></h3>
                <img src="" data-src="https://raw.githubusercontent.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/main/screenshots/${industry_key}.png" alt="${formatted_industry_name} Industry Image" class="chart-image" style="max-width:100%; height:auto; display:block; margin-bottom:2px;">
              </div>
            </div>\n`

          industry_counter += 1
        }
        container.innerHTML = sectionsHtml;
      }


        const BOT_TOKEN = '6506332831:AAG0wcG6LxQXNVDVyXw_lBBa1YNDGV_Mhj0';
        const API_URL = `https://api.telegram.org/bot${BOT_TOKEN}/getUpdates`;
        const DILUTION_DATA_FILENAME = "all_industries_detailed_dilution_results.json";
        const DATA_URL = GITHUB_RAW_URL_BASE + DILUTION_DATA_FILENAME;

        async function getTelegramTickerData() {
            try {
                const response = await fetch(API_URL);
                const data = await response.json();

                if (!data.ok) throw new Error("API Error: " + data.description);

                const tickerDict = {};

                // 1. Calculate the start of the current day (00:00:00) in Unix time
                const now = new Date();
                const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime() / 1000;

                const updates = data.result;

                updates.forEach(update => {
                    // Telegram channels use 'channel_post'; groups use 'message'
                    const post = update.channel_post || update.message;

                    // 2. Filter: Must have text AND date must be >= start of today
                    if (post && post.text && post.date >= startOfToday) {
                        const text = post.text.trim();

                        // 3. Parse format: TICKER - VAL1 - VAL2 - VAL3
                        const parts = text.split('-').map(p => p.trim());

                        if (parts.length >= 4) {
                            const ticker = parts[0].toUpperCase();
                            tickerDict[ticker] = {
                                ticker: ticker,
                                val1: parts[1],
                                val2: parts[2],
                                val3: parts[3],
                                time: new Date(post.date * 1000).toLocaleTimeString()
                            };
                        }
                    }
                });

                console.log(`Extracted ${Object.keys(tickerDict).length} tickers from telegram today:`, tickerDict);
                return tickerDict;

            } catch (error) {
                console.error("Failed to fetch messages:", error);
                return {};
            }
        }

        //const fundamentalsLookup = {};
        //fundamentalsData.forEach(item => {
        //    fundamentalsLookup[item.ticker.toUpperCase()] = item;
        //});

        // Create a global lookup for options data
        //const optionsLookup = {};
        //optionsRangesMap.forEach(item => {
        //    optionsLookup[item.ticker.toUpperCase()] = item;
        //});


        // Function to parse price ranges like "$185.00 – $205.00" or single values "$93.00"
        function parsePriceRange(rangeStr) {
            if (!rangeStr || typeof rangeStr !== 'string') return { min: NaN, max: NaN };

            // Clean the string by removing dollar signs and commas first
            const cleanStr = rangeStr.replace(/[$,]/g, '').trim();

            // Attempt to match a range pattern: e.g., "X.XX - Y.YY" or "X.YY – Y.YY"
            const rangeMatch = cleanStr.match(/(\d+(?:\.\d+)?)\s*[–-]\s*(\d+(?:\.\d+)?)/);

            if (rangeMatch && rangeMatch.length >= 3) { // group 0 is full match, 1 is first number, 2 is second number
                const num1 = parseFloat(rangeMatch[1]);
                const num2 = parseFloat(rangeMatch[2]); // Corrected from rangeMatch[3]
                if (!isNaN(num1) && !isNaN(num2)) {
                    return { min: Math.min(num1, num2), max: Math.max(num1, num2) };
                }
            }

            // If no range pattern is found, try to extract a single number
            const singleNumberMatch = cleanStr.match(/(\d+(?:\.\d+)?)/); // Use capturing group here
            if (singleNumberMatch && singleNumberMatch.length >= 2) { // group 0 is full match, 1 is the number
                const num = parseFloat(singleNumberMatch[1]); // Corrected to singleNumberMatch[1]
                if (!isNaN(num)) {
                    return { min: num, max: num };
                }
            }
            return { min: NaN, max: NaN };
        }

        // Helper to convert hex to RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b];
        }

        // Linear interpolation for colors
        function lerpColor(color1, color2, ratio) {
            const r = Math.round(color1[0] + (color2[0] - color1[0]) * ratio);
            const g = Math.round(color1[1] + (color2[1] - color1[1]) * ratio);
            const b = Math.round(color1[2] + (color2[2] - color1[2]) * ratio);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Function to get color at a specific percentage on the gradient
        function getColorAtGradientPosition(position) {
            const green = hexToRgb('#4CAF50'); // 0%
            const yellow = hexToRgb('#FFEB3B'); // 50%
            const red = hexToRgb('#F44336'); // 100%
            if (position <= 50) {
                const ratio = position / 50; // Normalize to 0-1 range for green to yellow segment
                return lerpColor(green, yellow, ratio);
            } else {
                const ratio = (position - 50) / 50; // Normalize to 0-1 range for yellow to red segment
                return lerpColor(yellow, red, ratio);
            }
        }



        // JavaScript function for conditional coloring of 'price%' column
        function colorPricePercent(val) {
            try {
                val = parseFloat(val);
            } catch (e) {
                return ''; // No coloring for non-numeric values
            }

            if (isNaN(val)) return '';

            if (val <= -10) {
                return 'background-color: #8B0000; color: white;'; // Dark Red
            } else if (val >= 10) {
                return 'background-color: #006400; color: white;'; // Dark Green
            } else if (val < 0) { // Between -10 and 0, scale from white to dark red
                let ratio = Math.abs(val) / 10.0;
                let r = parseInt(255 - (255 - 139) * ratio);
                let g = parseInt(255 - (255 - 0) * ratio);
                let b = parseInt(255 - (255 - 0) * ratio);
                return `background-color: rgb(${r}, ${g}, ${b});`;
            } else if (val > 0) { // Between 0 and 10, scale from white to dark green
                let ratio = val / 10.0;
                let r = parseInt(255 - (255 - 0) * ratio);
                let g = parseInt(255 - (255 - 100) * ratio);
                let b = parseInt(255 - (255 - 0) * ratio);
                return `background-color: rgb(${r}, ${g}, ${b});`;
            } else { // val == 0
                return 'background-color: white;';
            }
        }
         // Functions for inline dilution window
        function toggleDilutionInline(element, ticker, event, currentPrice) {
            event.stopPropagation(); // Prevent default button action or parent click
            const popup = document.getElementById('dilution-inline-popup');
            const backdrop = document.getElementById('dilution-backdrop');

            if (popup.classList.contains('active') && popup.dataset.currentType === 'dilution' && popup.dataset.currentTicker === ticker) {
                // If it's already active and for the same ticker, close it
                closeDilutionInline();
                return;
            }

            // Check if dilution data is loaded before proceeding
            if (Object.keys(tickerDilutionMap).length === 0) {
                console.warn("Dilution data not yet loaded. Please wait and try again.");
                // Optionally show a message to the user
                // alert("Dilution data is still loading. Please try again in a moment.");
                return;
            }

            if (tickerDilutionMap[ticker]) {
                // Set content
                popup.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Dilution Details for ${ticker}(Price: $${currentPrice})</h3>
                        <button onclick="closeDilutionInline()" style="background: none; border: none; font-size: 1.5em; cursor: pointer;">&times;</button>
                    </div>
                    <div class="popup-content-scroll">${marked.parse(tickerDilutionMap[ticker])}</div>
                `;
                popup.dataset.currentType = 'dilution'; // Mark popup type
                popup.dataset.currentTicker = ticker; // Store current ticker
                popup.classList.add('active');
                backdrop.classList.add('active');
            } else {
                console.log(`No dilution data found for ticker: ${ticker}`);
                // Optionally show a message to the user
                // alert(`No detailed dilution data available for ${ticker}.`);
            }
        }

        function toggleOptionsLevelsInline(element, industryKey, tickerpricestr, event) {
            event.stopPropagation(); // Prevent default button action or parent click
            const popup = document.getElementById('dilution-inline-popup'); // Reuse the same popup
            const backdrop = document.getElementById('dilution-backdrop');

            if (popup.classList.contains('active') && popup.dataset.currentType === 'options' && popup.dataset.currentIndustry === industryKey) {
                // If it's already active for the same industry and type, close it
                closeDilutionInline(); // Reuse close function
                return;
            }

            let contentHtml = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0;">Options Levels Details for ${industryKey.replace('_', ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}</h3>
                    <button onclick="closeDilutionInline()" style="background: none; border: none; font-size: 1.5em; cursor: pointer;">&times;</button>
                </div>
                <div class="popup-content-scroll">`;

            if (industryDict[industryKey]) {
                contentHtml += `<h4>${tickerpricestr}</h4>`;
                contentHtml += `<div class="popup-markdown-content">${marked.parse(industryDict[industryKey])}</div>`;
            } else {
                contentHtml += `<h4>${industryKey}</h4><p>No detailed options data found.</p>`;
            }


            contentHtml += `</div>`;
            popup.innerHTML = contentHtml;
            popup.dataset.currentType = 'options'; // Mark popup type
            popup.dataset.currentIndustry = industryKey; // Store current industry
            popup.classList.add('active');
            backdrop.classList.add('active');
        }

        function toggleImageChart(industryKey) {
            const chartSection = document.getElementById(`charts-image-section-${industryKey}`);
            if (chartSection) {
                chartSection.classList.toggle('hidden');
                if (!chartSection.classList.contains('hidden')) {
                    // Find the specific image within this chartSection and load it
                    const img = chartSection.querySelector('.chart-image');
                    if (img) {
                        img.src = img.dataset.src;
                        console.log(`Loaded image for ${industryKey}:`, img.src);
                    }
                }
            }
        }

        function closeDilutionInline() {
            document.getElementById('dilution-inline-popup').classList.remove('active');
            document.getElementById('dilution-backdrop').classList.remove('active');
            document.getElementById('dilution-inline-popup').dataset.currentType = ''; // Clear current type
            document.getElementById('dilution-inline-popup').dataset.currentTicker = ''; // Clear current ticker
            document.getElementById('dilution-inline-popup').dataset.currentIndustry = ''; // Clear current industry
        }

        // Generic toggle function for sections
        function toggleSection(contentId, headerElement) {
            const content = document.getElementById(contentId);
            if (content) {
                content.classList.toggle('hidden');
                // If it's the image chart, and it's being shown, load the image
                if (!content.classList.contains('hidden') && contentId.startsWith('charts-image-section-')) {
                    const img = content.querySelector('.chart-image');
                    if (img && img.dataset.src) {
                        img.src = img.dataset.src;
                    }
                }
            }
        }
         // Function to load actual image sources for lazy loading
        function loadChartsImages() {
            console.log('loadChartsImages function called.');
            document.querySelectorAll('.chart-image').forEach(img => {
                console.log('Processing image:', img.alt);
                console.log('Current img.src:', img.src);
                console.log('Current img.dataset.src:', img.dataset.src);
                //if (!img.src) { // Only load if not already loaded
                    img.src = img.dataset.src;
                    //console.log('Image src set to:', img.src);
                //}
            });
        }
        // Function to render charts from provided data
        async function renderCharts(allCsvData) {
            try {
                const chartingData = allCsvData;
                console.log('Charting data received:', chartingData);


                for (const industryKey in tickerMap) {
                    const industryTickers = tickerMap[industryKey].map(t => t.toUpperCase()); // Ensure ticker case matches
                    const filteredChartingData = chartingData.filter(row => industryTickers.includes(row['Ticker'].toUpperCase()));

                    const chartCanvas = document.getElementById(`chart_${industryKey}`);
                    if (!chartCanvas) {
                        console.warn(`Chart canvas not found for industry: ${industryKey}`);
                        continue;
                    }

                    if (filteredChartingData.length > 0) {
                        const labels = filteredChartingData.map(row => row['Ticker']);
                        const debtMcapRatios = filteredChartingData.map(row => {
                            const mcap = parseFloat(row['mcap']);
                            const debt_m = parseFloat(row['Debt_M']); // Use Debt_M from sheets_df
                            return mcap > 0 ? (debt_m / mcap * 100).toFixed(2) : 0;
                        });
                        const cashMcapRatios = filteredChartingData.map(row => {
                            const mcap = parseFloat(row['mcap']);
                            const cash_m = parseFloat(row['Cash_M']); // Use Cash_M from sheets_df
                            return mcap > 0 ? (cash_m / mcap * 100).toFixed(2) : 0;
                        });
                        const siPercents = filteredChartingData.map(row => parseFloat(row['SI%']) || 0);
                        const institutesPercents = filteredChartingData.map(row => parseFloat(row['institutes%']) || 0);

                        // Calculate Burn/Market Cap (%)
                        const burnMcapRatios = filteredChartingData.map(row => {
                            const mcap = parseFloat(row['mcap']);
                            const tickerUpper = row['Ticker'].toUpperCase();
                            const fundData = fundamentalsLookup[tickerUpper];
                            if (fundData && mcap > 0) {
                                const burn = parseFloat(fundData['burn']);
                                return (burn / mcap * 100).toFixed(2);
                            }
                            return 0; // Default to 0 if data is missing or mcap is zero
                        });
                        new Chart(chartCanvas, {
                            type: 'bar',
                            data: {
                                labels: labels,
                                datasets: [
                                    {
                                        label: 'Debt%',
                                        data: debtMcapRatios,
                                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                                        borderColor: 'rgba(255, 99, 132, 1)',
                                        borderWidth: 1
                                    },
                                    {
                                        label: 'Cash%',
                                        data: cashMcapRatios,
                                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                                        borderColor: 'rgba(54, 162, 235, 1)',
                                        borderWidth: 1
                                    },
                                    {
                                        label: 'SI%',
                                        data: siPercents,
                                        backgroundColor: 'rgba(255, 206, 86, 0.6)',
                                        borderColor: 'rgba(255, 206, 86, 1)',
                                        borderWidth: 1
                                    },
                                    {
                                        label: 'tutes%',
                                        data: institutesPercents,
                                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                                        borderColor: 'rgba(75, 192, 192, 1)',
                                        borderWidth: 1
                                    },
                                    {
                                        label: 'Burn%',
                                        data: burnMcapRatios,
                                        backgroundColor: 'rgba(153, 102, 255, 0.6)', // A new color
                                        borderColor: 'rgba(153, 102, 255, 1)',
                                        borderWidth: 1
                                    }
                                    ]
                            },
                            options: {
                                responsive: true,
                                animation: false,
                                events: [],
                                aspectRatio: 4,
                                maintainAspectRatio: true,
                                scales: {
                                    x: {
                                        stacked: false,
                                        title: {
                                            display: false,
                                            text: 'Ticker'
                                        }
                                    },
                                    y: {
                                        beginAtZero: true,
                                        title: {
                                            display: false,
                                            text: 'Percentage (%)'
                                        }
                                    }
                                },
                                plugins: {
                                      datalabels: {
                                        anchor: 'end',
                                        align: 'top',
                                        formatter: (value) => {
                                            return parseFloat(value).toFixed(1);
                                        },
                                        color: '#333',
                                        font: {
                                            weight: 'bold',
                                            size: 10
                                        }
                                    },
                                    title: {
                                        display: false,
                                        text: `Peer Comparison for ${industryKey.replace('_', ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}`
                                    },
                                    legend: {
                                        display: true,
                                        position: 'top'
                                    }
                                }
                            }
                        });

                    } else {
                        chartCanvas.parentElement.innerHTML = '<p>No charting data available for this industry.</p>';
                    }
                }
            } catch (error) {
                console.error('Error rendering charts:', error); // Changed log message
                for (const industryKey in tickerMap) {
                    const chartCanvas = document.getElementById(`chart_${industryKey}`);
                    if (chartCanvas) {
                        chartCanvas.parentElement.innerHTML = `<p>Error loading charting data: ${error.message}</p>`;
                    }
                }
            }
        }
        // Function to fetch CSV data and render tables (fundamentals)
        async function fetchAndRenderTables() {
            const telegramTickerData = await getTelegramTickerData();
            try {
                // Call renderCharts with the parsed data
                renderCharts(csvdata);

                // Columns to display (must match Python list in sheets_df)
                const columnsToDisplay = [
                    'price%', 'Ticker', 'Price', 'mcap',
                    'Open','High','Low','HL' //,'OrderBook'
                ];

                for (const industryKey in tickerMap) {
                    const industryTickers = tickerMap[industryKey];
                    const industryData = csvdata.filter(row => industryTickers.includes(row['Ticker'].toLowerCase()));

                    industryData.sort((a, b) => {
                        const mcapA = parseFloat(a['mcap']) || 0;
                        const mcapB = parseFloat(b['mcap']) || 0;
                        return mcapB - mcapA; // Decreasing order
                    });

                    const placeholderDiv = document.getElementById(`fundamentals-table-${industryKey}`);
                    if (!placeholderDiv) {
                        console.warn(`Placeholder div not found for industry: ${industryKey}`);
                        continue;
                    }

                    if (industryData.length > 0) {
                        let tableHtml = '<table class="\dataframe"><thead><tr>';
                        const actualHeaders = headers.filter(h => columnsToDisplay.includes(h) && industryData[0].hasOwnProperty(h));

                        actualHeaders.forEach(header => {
                            tableHtml += `<th>${header}</th>`;
                        });
                        tableHtml += '</tr></thead><tbody>';

                        industryData.forEach(row => {
                            tableHtml += '<tr>';
                            actualHeaders.forEach(header => {
                                let cellValue = row[header] || '';
                                let tdClass = '';
                                let style = '';
                                // Try to override with fundamentalsData if available and applicable
                                const tickerUpper = row['Ticker'].toUpperCase();
                                const fundData = fundamentalsLookup[tickerUpper];
                                //const dailyData = telegramTickerData[tickerUpper];
                                if (fundData) {
                                    if (header === 'Debt_M') {
                                        cellValue = fundData['debt'] !== undefined ? fundData['debt'] : cellValue;
                                    } else if (header === 'Cash_M') {
                                        cellValue = fundData['cash'] !== undefined ? fundData['cash'] : cellValue;
                                    } else if (header === 'QRevenue_M') {
                                        cellValue = fundData['rev'] !== undefined ? fundData['rev'] : cellValue;
                                    } else if (header === 'QPL_M') { // Assuming QPL_M from sheets_df maps to 'burn' from fundamentalsData
                                        cellValue = fundData['burn'] !== undefined ? fundData['burn'] : cellValue;
                                    } else if (['mcap', 'Price', 'High', 'Low', 'Open'].includes(header)) {
                                        cellValue = '';
                                    //} else if (header === 'OrderBook' && dailyData && dailyData.val3 !== undefined) {
                                    } else if (header === 'HL') {
                                        //cellValue = dailyData.val3;
                                        style = 'text-align: right; paddingRight: 20px; color: brown;';
                                    }
                                }

                                if (!isNaN(parseFloat(cellValue)) && isFinite(cellValue)) {
                                    cellValue = parseFloat(cellValue).toString();
                                }
                                let displayValue = cellValue;
                                if (header === 'price%') {
                                    displayValue = '';
                                    style = colorPricePercent(cellValue);
                                    tdClass = 'price-percent-col';
                                }
                                if (header === 'Ticker') {
                                    const ticker = cellValue.toUpperCase();
                                    const price = row['Price'] || 'N/A'; // Get the price
                                    if (tickerDilutionMap[ticker]) {
                                        displayValue = `
                                            <button class="ticker-button" onclick="toggleDilutionInline(this, '${ticker}', event, '${price}')">
                                                ${cellValue}
                                            </button>
                                        `;
                                    }
                                }
                                tableHtml += `<td class="${tdClass}" style="${style}">${displayValue}</td>`;
                            });
                            tableHtml += '</tr>';
                            const currentPrice = parseFloat(row['Price']) || NaN;
                            let ceilingRange = {min: NaN, max: NaN};
                            let floorRange = {min: NaN, max: NaN};

                            const tickerUpper = row['Ticker'].toUpperCase();
                            if (customDilutionRangesLookup[tickerUpper]) {
                                const customRanges = customDilutionRangesLookup[tickerUpper];
                                ceilingRange = customRanges.ceiling;
                                floorRange = customRanges.floor;
                            }
                            const optionsData = optionsLookup[tickerUpper];
                            let overallMin = currentPrice;
                            let overallMax = currentPrice;
                            const highPrice = parseFloat(row['High']) || NaN;
                            const lowPrice = parseFloat(row['Low']) || NaN;
                            const openPrice = parseFloat(row['Open']) || NaN; // Get the Open price
                            if (!isNaN(highPrice)) overallMax = Math.max(overallMax, highPrice);
                            if (!isNaN(lowPrice)) overallMin = Math.min(overallMin, lowPrice);
                            if (!isNaN(openPrice)) { // Add openPrice to overall min/max calculation
                                overallMax = Math.max(overallMax, openPrice);
                                overallMin = Math.min(overallMin, openPrice);
                            }

                            if (!isNaN(ceilingRange.min)) overallMax = Math.max(overallMax, ceilingRange.min);
                            if (!isNaN(ceilingRange.max)) overallMax = Math.max(overallMax, ceilingRange.max);
                            if (!isNaN(floorRange.min)) overallMin = Math.min(overallMin, floorRange.min);
                            if (!isNaN(floorRange.max)) overallMin = Math.min(overallMin, floorRange.max);

                            let putwall = NaN;
                            let callwall = NaN;
                            let gammaflip = NaN;
                            let maxpain = NaN;

                            if (optionsData) {
                                putwall = parseFloat(optionsData['putwall']);
                                callwall = parseFloat(optionsData['callwall']);
                                gammaflip = parseFloat(optionsData['gammaflip']);
                                maxpain = parseFloat(optionsData['maxpain']);

                                if (!isNaN(putwall)) overallMin = Math.min(overallMin, putwall);
                                if (!isNaN(callwall)) overallMax = Math.max(overallMax, callwall);
                            }

                            let weeklycandleHtml = '';
                            if (!isNaN(openPrice) && !isNaN(highPrice) && !isNaN(lowPrice) && !isNaN(overallMin) && !isNaN(overallMax) && overallMin < overallMax) {
                                const range = overallMax - overallMin;
                                const clampPosition = (value) => Math.max(0, Math.min(100, (value - overallMin) / range * 100));

                                const openPos = clampPosition(openPrice);
                                const highPos = clampPosition(highPrice);
                                const lowPos = clampPosition(lowPrice);
                                const currentPricePos = clampPosition(currentPrice);

                                weeklycandleHtml = `
                                    <tr class="weekly-candle-line-row">
                                        <td colspan="${actualHeaders.length}" style="padding: 0px;">
                                            <div style="position: relative; top:0px; width: 100%; height: 4px; border-radius: 5px; background-color: #ddd;">
                                                ${
                                                    !isNaN(lowPrice) && !isNaN(highPrice) && lowPrice <= highPrice ?
                                                    `<div style="position: absolute; top:2px; left: ${clampPosition(lowPrice)}%; width: ${Math.max(0, clampPosition(highPrice) - clampPosition(lowPrice))}%; height: 100%; background-color: DeepSkyBlue; border-radius: 5px;"></div>`
                                                    : ''
                                                }
                                                <!-- Open/close price vertical line marker -->
                                                <div style="position: absolute; left: ${openPos}%; top: -2px; width: 2px; height: 8px; background-color: DeepSkyBlue; transform: translateX(-50%); z-index: 3;"></div>
                                                <div style="position: absolute; left: ${currentPricePos}%; top: 2px; width: 2px; height: 8px; background-color: DeepSkyBlue; transform: translateX(-50%); z-index: 3;"></div>
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }


                            let lineHtml = ''; // For dilution line
                            let optionsLineHtml = ''; // For options line
                            const getPctDist = (targetValue) => {
                                if (!currentPrice || currentPrice === 0 || targetValue === 0) return 0;
                                return Math.round(((targetValue - currentPrice) / currentPrice) * 100);
                            };
                            if (!isNaN(overallMin) && !isNaN(overallMax) && overallMin < overallMax) {
                                const range = overallMax - overallMin;
                                // Helper to clamp positions between 0 and 100%
                                const clampPosition = (value) => Math.max(0, Math.min(100, (value - overallMin) / range * 100));
                                const pricePosition = clampPosition(currentPrice);
                                rowBackgroundColor = getColorAtGradientPosition(pricePosition);
                                // Calculate positions for floor/ceiling range arrows
                                const floorMinPos = clampPosition(floorRange.min);
                                const floorMaxPos = clampPosition(floorRange.max);
                                const ceilMinPos = clampPosition(ceilingRange.min);
                                const ceilMaxPos = clampPosition(ceilingRange.max);

                                lineHtml = `
                                    <tr class="price-line-row">
                                        <td colspan="${actualHeaders.length}" style="padding: 0px;">
                                            <div style="position: relative; width: 100%; height: 4px; border-radius: 5px; background-color: #ddd;"> <!-- Base grey line -->
                                                ${
                                                    !isNaN(floorRange.min) && !isNaN(ceilingRange.max) && floorRange.min <= ceilingRange.max ?
                                                    `<div style="position: absolute; top:2px; left: ${clampPosition(floorRange.min)}%; width: ${Math.max(0, clampPosition(ceilingRange.max) - clampPosition(floorRange.min))}%; height: 100%; background-color: ${rowBackgroundColor}; border-radius: 5px;"></div>`
                                                    : ''
                                                }
                                                <!--div style="position: absolute; left: ${pricePosition}%; top: -3px; width: 10px; height: 10px; background-color: #333; border-radius: 50%; transform: translateX(-50%); box-shadow: 0 0 5px rgba(0,0,0,0.5);" title="${currentPrice.toFixed(2)}"></div-->
                                                <span style="position: absolute; left: ${pricePosition}%; top: -12px; transform: translateX(-50%); font-weight: bold; font-size: 1.5em; color: black;">$&nbsp;</span>
                                                <span style="position: absolute; left: ${pricePosition}%; top: -26px; transform: translateX(-50%); font-size: 0.8em; color: dimgrey;">$${currentPrice.toFixed(2)}</span>

                                                ${!isNaN(floorRange.min) ? `<span class="arrow-right-green" style="left: ${floorMinPos}%;" title="${floorRange.min.toFixed(2)}"></span>` : ''}
                                                ${!isNaN(floorRange.max) ? `<span class="arrow-right-green" style="left: ${floorMaxPos}%;" title="${floorRange.max.toFixed(2)}"></span>` : ''}
                                                ${!isNaN(ceilingRange.min) ? `<span class="arrow-left-red" style="left: ${ceilMinPos}%;" title="${ceilingRange.min.toFixed(2)}"></span>` : ''}
                                                ${!isNaN(ceilingRange.max) ? `<span class="arrow-left-red" style="left: ${ceilMaxPos}%;" title="${ceilingRange.max.toFixed(2)}"></span>` : ''}
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }


                            if (optionsData) {
                                // Check if values are valid and a meaningful range exists
                                if (!isNaN(putwall) && !isNaN(callwall) && !isNaN(gammaflip) && !isNaN(maxpain) && putwall < callwall) {
                                    const range = overallMax - overallMin;
                                    const clampPosition = (value) => Math.max(0, Math.min(100, (value - overallMin) / range * 100));
                                    const optionsRange = callwall - putwall;
                                    const optionsClampPosition = (value) => Math.max(0, Math.min(100, (value - putwall) / optionsRange * 100));

                                    const optionsPricePosition = optionsClampPosition(currentPrice);
                                    const optionsRowBacPkgroundColor = getColorAtGradientPosition(optionsPricePosition);
                                    const putwallPos = clampPosition(putwall);
                                    const callwallPos = clampPosition(callwall);
                                    const gammaflipPos = clampPosition(gammaflip);
                                    const maxpainPos = clampPosition(maxpain);

                                    // Calculate background color for options line
                                    const pricePosition = clampPosition(currentPrice);
                                    const distToPutWall = getPctDist(putwall);
                                    const distToCallWall = getPctDist(callwall);
                                    optionsLineHtml = `
                                        <tr class="options-price-line-row">
                                            <td colspan="${actualHeaders.length}" style="padding: 0px;">
                                                <div style="position: relative; width: 100%; height: 4px; border-radius: 5px; background-color: #ddd;"> <!-- Base grey line -->
                                                    ${
                                                        !isNaN(putwall) && !isNaN(callwall) && putwall <= callwall ?
                                                        `<div style="position: absolute; top:-2px; left: ${clampPosition(putwall)}%; width: ${Math.max(0, clampPosition(callwall) - clampPosition(putwall))}%; height: 100%; background-color: ${optionsRowBacPkgroundColor}; border-radius: 5px;"></div>`
                                                        : ''
                                                    }
                                                    <!-- Put Wall Text -->
                                                    <span style="position: absolute; left: ${putwallPos}%; top: -12px; width: auto; height: auto; padding: 0 3px; background-color: green; color: white; border-radius: 3px; transform: translateX(-50%); font-weight: bold; font-size: 0.8em;" title="$${putwall.toFixed(2)}">W</span>
                                                    <span style="position: absolute; left: ${putwallPos}%; top: -26px; transform: translateX(-50%); font-size: 0.8em; color: dimgrey;">${distToPutWall.toFixed(0)}</span>

                                                    <!-- Call Wall Text -->
                                                    <span style="position: absolute; left: ${callwallPos}%; top: -12px; width: auto; height: auto; padding: 0 3px; background-color: red; color: white; border-radius: 3px; transform: translateX(-50%); font-weight: bold; font-size: 0.8em;" title="$${callwall.toFixed(2)}">W</span>
                                                    <span style="position: absolute; left: ${callwallPos}%; top: -26px; transform: translateX(-50%); font-size: 0.8em; color: dimgrey;">${distToCallWall.toFixed(0)}</span>

                                                    <!-- Current Price Dot (black) -->
                                                    <!--div style="position: absolute; left: ${pricePosition}%; top: -3px; width: 10px; height: 10px; background-color: black; border-radius: 50%; transform: translateX(-50%); box-shadow: 0 0 5px rgba(0,0,0,0.5);title=""></div-->
                                                   <!-- Gamma Flip Character (blue) -->
                                                    <span style="position: absolute; left: ${gammaflipPos}%; top: -12px; width: auto; height: auto; padding: 0 3px; background-color: blue; color: white; border-radius: 3px; transform: translateX(-50%); font-weight: bold; font-size: 0.8em;" title="$${gammaflip.toFixed(2)}">F</span>
                                                    <!-- Max Pain Character (green) -->
                                                    <span style="position: absolute; left: ${maxpainPos}%; top: -12px; width: auto; height: auto; padding: 0 3px; background-color: green; color: white; border-radius: 3px; transform: translateX(-50%); font-weight: bold; font-size: 0.8em;" title="$${maxpain.toFixed(2)}">P</span>
                                                </div>
                                            </td>
                                        </tr>
                                    `;
                                }
                            }
                            tableHtml += optionsLineHtml;
                            tableHtml += weeklycandleHtml;
                            tableHtml += lineHtml;
                        });
                        tableHtml += '</tbody></table>';
                        placeholderDiv.innerHTML = tableHtml;
                    } else {
                        placeholderDiv.innerHTML = '<p>No fundamentals data available for this industry.</p>';
                    }
                }
            } catch (error) {
                console.error('Error fetching or processing CSV:', error);
                for (const industryKey in tickerMap) {
                    const placeholderDiv = document.getElementById(`fundamentals-table-${industryKey}`);
                    if (placeholderDiv) {
                        placeholderDiv.innerHTML = `<p>Error loading fundamentals data: ${error.message}</p>`;
                    }
                }
            }
        }


    </script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        h1 { color: #0056b3; border-bottom: 2px solid #0056b3; padding-bottom: 10px; }
        h2 { color: #004085; margin-top: 25px; }
        h3 { color: #002d6b; margin-top: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; background-color: #f4f4f4; box-shadow: none; border: none; } /* Modified table styling */
        th, td { border: none; padding: 8px; text-align: left; } /* Modified table cell styling */
        th { display: none; } /* Hide table headers */
        td { color: #002d6b; } /* Make text color same as page background */
        .news-item { background-color: #e9f7ef; border-left: 5px solid #28a745; margin-bottom: 10px; padding: 10px; border-radius: 4px; } /* Added news item styling */
        .news-date { font-weight: bold; color: #28a745; } /* Added news date styling */
        .ticker-header { background-color: #d1ecf1; padding: 8px; margin-top: 15px; margin-bottom: 5px; border-radius: 4px; border-left: 5px solid #17a2b8; } /* Added ticker header styling */
        /* Style for markdown content */
        .markdown-output {
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            background-color: #f9f9f9;
            margin-top: 15px;
        }
        .markdown-output h1, .markdown-output h2, .markdown-output h3, .markdown-output h4, .markdown-output h5, .markdown-output h6 {
            border-bottom: 1px solid #eee;
            padding-bottom: 0.3em;
            margin-top: 1em;
            margin-bottom: 0.5em;
            line-height: 1.25;
        }
        .markdown-output ul, .markdown-output ol {
            padding-left: 2em;
        }
        .markdown-output blockquote {
            color: #6a737d;
            border-left: 0.25em solid #dfe2e5;
            padding: 0 1em;
            margin-left: 0;
        }
        .markdown-output pre {
            background-color: #f6f8fa;
            border-radius: 3px;
            padding: 1em;
            overflow: auto;
        }
        .markdown-output code {
            background-color: rgba(27,31,35,.5);
            border-radius: 3px;
            padding: 0.2em 0.4em;
            font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;
        }
        .statement {
            /* Treat each statement as a block to force a new line */
            display: block;
            /* Optional: Add some spacing between lines */
            margin: 6px 0;
            /* Inherit the small/italic formatting from the original input */
            font-style: italic;
            font-size: small;
        }
        .scroll-to-top-button {
            float: right;
            margin-left: 10px;
            text-decoration: none;
            font-size: 1.5em;
            color: #0056b3;
        }
        .hidden { display: none; }

        /* New CSS for inline dilution popup */
        .dilution-inline-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 1001; /* Higher than backdrop */
            max-width: 80%;
            max-height: 80%;
            overflow: hidden; /* Manage content scroll separately */
            border-radius: 8px;
            display: none; /* Hidden by default */
            flex-direction: column; /* To manage header and scrollable content */
        }
        .dilution-inline-popup.active {
            display: flex; /* Show when active */
        }
        .dilution-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5); /* Semi-transparent black overlay */
            z-index: 1000; /* Behind popup */
            display: none; /* Hidden by default */
        }
        .dilution-backdrop.active {
            display: block; /* Show when active */
        }
        .popup-content-scroll {
            flex-grow: 1; /* Allow content to take available space */
            overflow-y: auto; /* Enable vertical scrolling for content */
            padding-right: 10px; /* Space for scrollbar */
        }
        .ticker-button {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            font: inherit;
            cursor: pointer;
            text-decoration: underline;
            color: #0056b3; /* Or your preferred link color */
            display: inline-block; /* To allow padding/margins if needed */
        }
        .ticker-button:hover {
            color: #003366;
            text-decoration: none;
        }

        .toggle-header { cursor: pointer; }
        .toggle-icon { margin-left: 10px; }
        .price-percent-col {
            width: 5px;
            padding: 0;
        }
        /* CSS for arrowheads */
        .arrow-right-green,
        .arrow-left-red {
            position: absolute;
            top: -2px; /* Adjust to align with the line */
            width: 0; /* No width for the base of the arrow */
            height: 0; /* No height for the base of the arrow */
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: translateX(-50%); /* Center the arrow horizontally */
            z-index: 2; /* Ensure arrows are above the colored line */
        }

        .arrow-right-green {
            border-left: 8px solid green; /* Right-pointing arrow */
        }

        .arrow-left-red {
            border-right: 8px solid red; /* Left-pointing arrow */
        }
        .industry-header-container {
            display: flex;
            align-items: baseline; /* Aligns the text baselines of h2 and buttons */
            flex-wrap: wrap; /* Allows items to wrap on smaller screens */
            gap: 10px; /* Space between items */
        }
        .section-toggles-inline .ticker-button {
            font-size: 0.8em; /* Smaller font for inline buttons */
            padding: 2px 5px;
        }
    </style>
</head>
<body id="top">
    <div id="dilution-backdrop" class="dilution-backdrop"></div>
    <div id="dilution-inline-popup" class="dilution-inline-popup"></div>
    <h1>NASDAQ S&P Growth Stoks AI generated fundamentals technicals and Latest updates</h1>
    <h2 class="toggle-header" onclick="toggleSection('govt-news-content', this)">
        Government and Prominent Investor News <span class="toggle-icon">&darr;</span>
    </h2>
    <div id="govt-news-content" class="hidden">
        <div id="govt-news-markdown-output" class="markdown-output govt-news-section">
            Loading government and prominent investor news...
        </div>
    </div>
    <div id="industry-index-placeholder"></div>
    <div style="margin-top: 20px; margin-bottom: 20px;">
        <label><input type="checkbox" id="toggleNews"> News</label>
        <label><input type="checkbox" id="toggleFundamentalsTable" checked> Price levels </label>
        <label><input type="checkbox" id="toggleCanvasChart"> Fundamentals </label>
        <label><input type="checkbox" id="toggleCharts"> Technicals </label>
    </div>
    <div id='industry-sections-placeholder'></div>

  <script>
    document.addEventListener('DOMContentLoaded', async function() {
        // Fetch dilution data first
        await parseCsv();
        generateIndustryIndex();
        generateIndustrySections();
        renderDashboard();
        await fetchDilutionData();
        // Parse custom dilution ranges from the embedded string
        await parseCustomDilutionRanges();
        await loadAndCleanIndustryData();
        await fetchAndParseGovtNews();
        await fetchAndParseAllIndustriesNews(); // Call the new function here
        await fetchAndParseFundamentalsData()
        // Then call the function to fetch and render fundamentals tables, which will then call renderCharts
        await fetchAndParseOptionsData()
        fetchAndRenderTables();
        await fetchAndPopulateImageUpdateDates()
        // Configure marked.js if needed (e.g., to sanitize HTML)
        // marked.setOptions({ sanitize: true });

        const markdownBlocks = document.querySelectorAll('.markdown-raw-content');
        markdownBlocks.forEach(block => {
            // Decode HTML entities before passing to marked.js, as we escaped them earlier
            const rawMarkdown = block.innerHTML;
            const decodedMarkdown = new DOMParser().parseFromString(rawMarkdown, 'text/html').documentElement.textContent;
            block.innerHTML = marked.parse(decodedMarkdown);
            block.classList.remove('markdown-raw-content'); // Remove the raw class
            block.classList.add('markdown-output'); // Add a class for styled output
        });

        // Process markdown content within the popup for options details
        const popupMarkdownBlocks = document.querySelectorAll('.popup-markdown-content');
        popupMarkdownBlocks.forEach(block => {
            const rawMarkdown = block.innerHTML;
            const decodedMarkdown = new DOMParser().parseFromString(rawMarkdown, 'text/html').documentElement.textContent;
            block.innerHTML = marked.parse(decodedMarkdown);
        });


        // Initial hiding of all relevant sections if not checked by default
        document.querySelectorAll('.news-content').forEach(element => {
            if (!document.getElementById('toggleNews').checked) element.classList.add('hidden');
        });

        document.querySelectorAll('.canvas-chart-content').forEach(element => {
            if (!document.getElementById('toggleCanvasChart').checked) element.classList.add('hidden');
        });
        document.querySelectorAll('.charts-image-content').forEach(element => {
            if (!document.getElementById('toggleCharts').checked) element.classList.add('hidden');
        });


        document.getElementById('toggleNews').addEventListener('change', function() {
            document.querySelectorAll('.news-content').forEach(element => {
                if (this.checked) { element.classList.remove('hidden'); } else { element.classList.add('hidden'); }
            });
        });

        document.getElementById('toggleFundamentalsTable').addEventListener('change', function() {
            document.querySelectorAll('.fundamentals-table-content').forEach(element => {
                if (this.checked) { element.classList.remove('hidden'); } else { element.classList.add('hidden'); }
            });
        });

        document.getElementById('toggleCanvasChart').addEventListener('change', function() {
            document.querySelectorAll('.canvas-chart-content').forEach(element => {
                if (this.checked) { element.classList.remove('hidden'); } else { element.classList.add('hidden'); }
            });
        });
        document.getElementById('toggleCharts').addEventListener('change', function() {
            const isChecked = this.checked;
            document.querySelectorAll('.charts-image-content').forEach(element => {
                if (isChecked) { element.classList.remove('hidden'); } else { element.classList.add('hidden'); }
            });
            if (isChecked) {
                loadChartsImages(); // Load images when charts are shown
            }
        });
        // Close dilution popup when clicking outside
        document.getElementById('dilution-backdrop').addEventListener('click', closeDilutionInline);
    });
  </script>

  <hr/>

  <p><small><i>This is not a financial advice and all the material and content provided is for study and research purposes only. The financials table and technical charts are not updated regularly. Errors in data is expected</i></small></p>
  <div class="container">
        <p style="font-size: 10px; color: #666; margin-top: 10px;">
        <b>Institutional levels:</b> <i style="color:green">▶ ▶</i> safe/buy zone; <b style="color:red">◀ ◀</b> sell/take profit;
        <b>Options levels:</b> <b style="color:#27ae60">W</b> (Put Wall), <b style="color:#c0392b">W</b> (Call Wall), <b style="color:#2980b9">F</b> (Gamma Flip), <b style="color:#27ae60">P</b> (Max Pain). May not be Updated daily.
        </p>
        <span class="statement">Form 4 within 2 days after insider selling/buying</span>
        <span class="statement">Form 144 at the time of sell order with broker by affiliate/insider</span>
        <span class="statement">Form 10k Anual audited stmnt</span>
        <span class="statement">Form S3 for shelf registration dilutive</span>
        <span class="statement">schedule 13D/13G(/A Amendment) control/passive invest report within 10 days of >5% acquisition of total stock</span>
        <span class="statement">Form 10Q Quarterly unaudited stmnt</span>
        <span class="statement">Form 8k/6k(foreigner) within 4 days of unscheduled events that has stock price implications</span>
        <span class="statement">Def 14A board updates shareholder voting</span>
        <span class="statement">A resale filing for shares tied to warrant exercises means allowing the holders to resell the shares after warrant excercise in the market</span>
        <span class="statement">completion of redemption of warrants generating cash, typically means company redeemed outstanding warrants, and investors exercised those warrants to buy shares(added to outstanding shares), providing the company with cash</span>
        <span class="statement">Form S8 offer RSU/stock options incentives to employees, directors, or consultants.</span>
        <span class="statement">After shelf/ATM filing, subsequent prospectus supplement Form 424B5 filing to find the exact amount, if any, that was sold or exchanged.</span>
    </div>
    </body>
</html>
